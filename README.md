                                                                                  Assignment Two
                                                                        Question One: Software Engineering 
	According to O'Regan (2022), software engineering is a computer science branch that deals with the design, development, testing, and maintenance of software applications. Software engineers adhere to the principles of engineering to develop reliable, efficient, and user-friendly software applications. On the other hand, traditional programming involves writing codes to solve individual problems. Traditional programmers do not follow a specific structured methodology in creating codes to resolve problems. 
	Software engineering and traditional programming have different scopes. Unlike traditional programmers who are primarily concerned with only coding to solve problems, software engineering involves the entire software development cycle, which includes completing requirement analysis to maintenance of developed software applications.  Traditional programming and software engineering have contrasting methodologies. Traditional programmers do not adhere to any structured methodology to create codes for resolving problems, whereas software engineering must adhere to structured methodologies and best practices, especially agile and waterfall, to manage and control the software development process. O'Regan (2022) adds that software engineering requires people to work in teams to develop applications, while traditional programming involves specific individuals who code on their own to solve problems. 
                                                                        Question Two: Software Development Lifecycle
	The Software Development Lifecycle (SDLC) has seven phases; planning, requirement, design, coding, testing, deployment, and maintenance. According to O'Regan (2022), the planning phase requires software engineers to define the purpose and scope of the software. For example, software engineers indicate the goals and objectives that applications should meet.  O'Regan (2022) states that the requirement phase expects software engineers to identify and document the requirements of proposed applications. Software engineers need to collaborate or engage with stakeholders, especially end users, to understand their needs and expectations. O'Regan (2022) adds that the design phase involves creating an architectural design that highlights the overall system architecture and a detailed design that reveals individual components of the proposed system with the different interactions. Next, O'Regan (2022) notes that the coding phase requires software engineers to translate designed documents of the system into executable codes using programming languages, such as Python, Java, or JavaScript. 
	Furthermore, O'Regan (2022) indicates that the testing phase entails assessing if the developed system or codes work as intended. Software engineers conduct different testing, including system, unit, acceptance, and integration, to assess working systems. O'Regan (2022) argues that software engineers release developed systems to end users in the deployment phase. In this phase, software engineers ensure that end users install and configure developed systems appropriately to resolve identified problems. Finally, O'Regan (2022) adds that the maintenance phase expects software engineers to fix bugs and issues that threaten the usability of developed systems. Software engineers install updates and improvements in the development systems in the maintenance phase to improve their performances and functionality.  
                                                                  Question Three: Agile vs. Waterfall Model
Waterfall Model 
	According to O'Regan (2022), the Waterfall model is a software development model. The model has six phases; requirement gathering, analysis and design, implementation, verification, deployment, and maintenance. In utilizing the waterfall model, O'Regan (2022) indicates that software developers must progress through a fixed sequence of six phases. The model is rigid as software developers must complete each phase before moving to the next one. For example, software developers must complete the requirement-gathering phase before moving to the analysis and design stage. O'Regan (2022) adds that the waterfall model is a documentation-heavy model. In this model, software developers must complete comprehensive documentation of all activities in each phase. Software developers prefer the waterfall model for projects with well-defined requirements with minimal risks of changes, such as regulatory compliance applications. 
Agile Model 
	O'Regan (2022) notes that the agile model is an iterative approach to delivering a software system or applications. The agile software development model has six phases; concept, inception, iteration, release, maintenance, and retirement. In applying the agile model, software developers develop applications in small, but incremental iterations. For example, software developers spend between two to four weeks on each iteration. The agile model is flexible and adaptive as it allows software developers to adapt to the changing requirements of their projects. The model is collaboration-focused as software developers must collaborate in cross-functional teams to accomplish their projects. Software developers prefer the agile model when working on projects with evolving requirements, such as startups. 
                                                                Question Four: Requirement Engineering 
	O'Regan (2022) argues that requirement engineering entails defining, establishing and documenting application requirements. Requirement engineering involves five phases; elicitation, analysis, specification, validation, and management. According to O'Regan (2022), the elicitation phase requires software engineers to interview, observe, or survey stakeholders to gather information about software requirements. In the analysis phase, software developers analyze software requirements to determine feasibility issues, ambiguities, and detect any defects. O'Regan (2022) notes that software developers must document system requirements concisely and comprehensively in the specification phase. In the validation phase, software developers must ensure that system requirements accurately reflect stakeholders’ needs. The management phase expects software developers to handle changes to system requirements over the project lifecycle. 
	The requirement engineering is important as it enables software developers to create systems or applications that meet users’ needs and expectations. Software developers use requirement engineering to create a clear foundation for designing and developing applications. The requirement engineering minimizes the risk of project development failure because developers understand and internalize all requirements. 
                                                            Question Five: Software Design Principles 
	O'Regan (2022) defines modularity as a fundamental design principle in software engineering that mandates software developers to create applications in a way that minimizes dependencies among the components of a system. The principle requires software developers to break down the software development into small and self-contained modules, which they can develop, test, and maintain independently. 
	Undeniably, modularity improves the maintainability and scalability of software systems. According to O'Regan (2022), modularity enhances maintainability by making the software development system easy to update and fix. Software engineers applying the modularity principle maintain systems by identifying, updating, and fixing individual modules without affecting the entire system. Also, O'Regan (2022) argues that modularity enhances the scalability of software systems as it makes the process simple, allowing software developers to add new features into software systems by integrating new modules. 
                                                              Question Six: Testing in Software Engineering 
	According to O'Regan (2022), testing in software engineering involves executing programs to find errors. Software engineering has four levels; unit, integration, system, and acceptable. O'Regan (2022) states that unit testing is the first round of software engineering testing that involves testing individual methods and functions of the classes, components, and modules that systems use. Software developers conduct unit testing to ensure each unit of a system works correctly in isolation. O'Regan (2022) argues that integration testing entails individual units of a system to determine how they work together. Software developers complete integration testing to verify that integrated units work together as expected in systems. Next, O'Regan (2022) notes that system testing involves testing a whole system to determine if it works appropriately. Software developers conduct system testing to ensure that they meet user needs and expectations. O'Regan (2022) states that acceptance testing requires software developers to permit end users and stakeholders to assess the effectiveness of their systems. Software developers complete acceptance testing to confirm that systems meet users’ needs, requirements, and expectations. 
	Software developers conduct testing of systems to identify bugs. According to O'Regan (2022), software developers test systems to identify and correct bugs or defects early in the software development process. Testing enables software developers to ensure the quality of systems. O'Regan (2022) indicates that software developers rely on testing to ensure that systems meet the needs, requirements, and expectations of end users. Also, software developers test systems to reduce risks. O'Regan (2022) argues that testing enables software developers to minimize the risk of failure during system production. Testing enables software developers to improve user satisfaction. O'Regan (2022) notes that testing allows software developers to ensure final systems are reliable, user-friendly, and functional to consumers. 
                                                                Question Seven: Version Control Systems 
	O'Regan (2022) argues that Version Control Systems (VCS) as software tools that software developers rely on to manage changes to source codes over time to track every modification to their codes. For instance, software developers use VCS to work together on individual projects simultaneously, track changes, and revert to previous versions. 
	Software developers use VCS to collaborate during software development. According to O'Regan (2022), software developers rely on VCS, especially Git and Github, to work on the same codebase without overwriting their personal changes. Software developers use VCS to track history during software development. O'Regan (2022) indicates that VCS keep a detailed history of changes that make software developers understand what codes are changed, who changed them, and why they change them during software development processes. Software developers use VCS to revert changes in software development processes. O'Regan (2022) notes that software developers use VCS to revert to previous versions of codes during the code development process. 
	Git is the main example of VCS. According to O'Regan (2022), Git is characterized by extensive repository history, distributed version control, branching, merging, and support for non-linear development. For example, the branching and merging features allow software developers to collaborate in developing software systems. Large organizations and open-source communities use Git and Github repositories to facilitate collaboration during software development processes. Also, subversion is an example of VCS. O'Regan (2022) argues that subversion is characterized by tagging, branching, atomic commits, centralized version control, and directory versioning. Large enterprises use subversion to manage large codebases when they prefer centralized systems. 
                                                Question Eight: Software Development Project
	O'Regan (2022) argues that software project managers serve as the liaison between the development team and other stakeholders, such as investors and users, in a software project. Mainly, software project managers engage in project planning. They collaborate with developers to define project scopes, schedules, and deliverables during software project development. O'Regan (2022) indicates that software project managers perform resource management. They allocate resources, such as tools, budget, and team members, to software development teams. O'Regan (2022) notes that software project managers facilitate stakeholders' communication during software development processes. They maintain consistent communication with stakeholders, especially developers and users, and provide project updates to organizations. O'Regan (2022) adds that software project managers complete quality assurance during software development projects. They ensure that projects meet quality standards and reviews. For example, software project managers test systems and collect reviews from stakeholders to ensure that systems meet their expectations. 
	Although most software project managers accomplish their roles, they encounter numerous challenges. According to O'Regan (2022), software project managers experience resource constraints. Some software project managers experience limited resources, such as finances and human resources, negatively affecting their roles. As a result, they must balance limited resources to ensure optimal utilization. O'Regan (2022) argues that software project managers experience time management challenges. Most software project managers struggle to manage time to meet deadlines and ensure quality development of systems. Finally, O'Regan (2022) indicates that software project managers encounter the challenge of stakeholder expectations. Most stakeholders have high expectations during software development. In this regard, software project managers struggle to manage and align stakeholders’ expectations with the reality of software development projects. 
                                            Question Nine: Software Maintainance 
According to O'Regan (2022), software maintenance is the process of changing, modifying, and updating software to improve performance and meet customers’ needs, preferences, and expectations. 
Software developers engage in four types of software maintenance; corrective, adaptive, perfective, and preventive. O'Regan (2022) argues that corrective maintenance involves addressing bugs, faults, and errors within software applications that software developers identify after deploying them. For example, software developers patch security vulnerabilities of web applications to make them protective. According to O'Regan (2022), adaptive maintenance allows software developers to modify software applications to adapt to changes in the environment. For instance, software developers update existing software applications to be compatible with new or improved operating systems. O'Regan (2022) adds that perfective maintenance requires software developers to enhance existing functionalities and features of systems to improve their performances. For instance, software developers add new features to systems based on users’ feedback, tastes, and preferences to enhance user experience. O'Regan (2022) indicates that preventive maintenance requires software developers to assess system development to identify and fix problems before users notice them or they become problems. For instance, software developers refactor codes during system development or maintenance to avoid future errors. 
O'Regan (2022) argues that software maintenance promotes user satisfaction. Software developers listen to users' feedback about their systems before instituting maintenance activities. The maintenance activities improve systems, resulting in user satisfaction. According to O'Regan (2022), software maintenance ensures the security of systems. Software developers maintain applications by keeping them secure against threats and vulnerabilities. As a result, software maintenance improves systems’ security, protecting user data. Ultimately, O'Regan (2022) indicates that software maintenance ensures the longevity of systems. Software developers rely on software maintenance to improve systems’ features to respond to changing users’ tastes, preferences, and needs. Hence, the systems’ longevity increases. 
                                          Question Ten: Ethical Consideration in Software Engineering 
	O'Regan (2022) indicates that privacy is one of the ethical issues that software developers encounter. Software developers must ensure that they protect and not misuse users’ data during software development and maintenance. If they fail to uphold users’ privacy, software developers are vulnerable to lawsuits. Software developers experience security issues. According to O'Regan (2022), software developers must make systems that are secure against breaches and attacks. If they fail to make secure systems, software developers risk making systems that hackers can easily breach. O'Regan (2022) indicates that software developers encounter the threat of bias and fairness. Software developers struggle to avoid biases in algorithms and ensure fairness in software decisions. 
	O'Regan (2022) argues that software developers can adhere to ethical standards by following codes of ethics. Software developers should adhere to a professional code of ethics developed by professional bodies. For example, Kenyan developers should adhere to a professional code of ethics enshrined in the constitution to operate ethically. O'Regan (2022) indicates that software developers comply with regulations to operate ethically. Software developers must operate with their countries’ laws and regulations guiding the development and deployment of applications. In Kenya, software developers must respect all rules and regulations established by the government to operate legally and ethically. Finally, O'Regan (2022) adds that software developers invest in continuous education to operate ethically. Software developers should invest in learning about ethical standards and practices in software development. For example, software developers should attend ethical seminars and workshops to learn and adhere to ethical standards. Therefore, software developers must operate ethically and legally to avoid legal troubles. 

Reference
O'Regan, G. (2022). Concise guide to software engineering: From fundamentals to application methods. Springer Nature.

